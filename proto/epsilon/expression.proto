
syntax = "proto3";

message Constant {
  enum Type {
    DENSE_MATRIX = 0;
    SPARSE_MATRIX = 1;
    SCALAR = 2;
  }
  Type constant_type = 1;

  // SCALAR
  double scalar = 2;

  // DENSE_MATRIX/SPARSE_MATRIX
  int32 m = 3;
  int32 n = 4;
  int32 nnz = 5;

  string data_location = 6;
  bytes data_value = 7;
}

message Variable {
  string variable_id = 1;
}

message Size {
  repeated int32 dim = 1;
}

message Slice {
  int32 start = 1;
  int32 stop = 2;
  int32 step = 3;
}

message Sign {
  enum Type {
    UNKNOWN = 0;
    NEGATIVE = 1;
    POSITIVE = 2;
    ZERO = 3;
  }
  Type sign_type = 1;
}

message Curvature {
  enum Type {
    UNKNOWN = 0;
    AFFINE = 1;
    CONVEX = 2;
    CONCAVE = 3;
    CONSTANT = 4;
  }
  Type curvature_type = 1;

  // Special classes of affine functions which have implementations for
  // composing proximal operators.

  // Elementwise function, e.g. A .* X
  bool elementwise = 2;
  // Scalar multiple, e.g. alpha * X
  bool scalar_multiple = 3;
}

message Cone {
  enum Type {
    UNKNOWN = 0;
    ZERO = 1;           // s == 0
    NON_NEGATIVE = 2;   // s >= 0
    SEMI_DEFINITE = 3;  // S >= 0
  }
  Type cone_type = 1;
}

message ProximalOperator {
  string name = 1;
}

message LinearMap {
  enum Type {
    UNKNOWN = 0;

    // Atomic linear maps
    DENSE_MATRIX = 1;
    SPARSE_MATRIX = 2;
    DIAGONAL_MATRIX = 3;
    SCALAR = 4;
    KRONECKER_PRODUCT = 5;

    // Operations on atomic linear maps
    TRANSPOSE = 6;
  }
  Type linear_map_type = 1;
  int32 m = 2;
  int32 n = 3;

  // DENSE/SPARSE/DIAGONAL
  Constant constant = 4;

  // SCALAR
  double scalar = 5;

  // KRONECKER_PRODUCT
  repeated LinearMap arg = 6;
}

message Expression {
  enum Type {
    // Default value
    UNKNOWN = 0;

    // Indicator (generalized inequality)
    INDICATOR = 1;

    // Leaf nodes
    CONSTANT = 2;
    VARIABLE = 3;

    // Add/multiply operators
    ADD = 10;
    MULTIPLY = 11;
    MULTIPLY_ELEMENTWISE = 12;

    // Linear operators
    INDEX = 20;
    NEGATE = 21;
    SUM = 22;
    TRANSPOSE = 23;
    HSTACK = 24;
    VSTACK = 25;
    TRACE = 26;
    RESHAPE = 27;
    ZERO = 28;

    // Elementwise functions
    ABS = 50;
    POWER = 51;
    SQUARE_ROOT = 52;
    LOG = 53;
    EXP = 54;
    HUBER = 55;
    ENTR = 56;
    LOGISTIC = 57;
    SCALED_ZONE = 58;
    KL_DIV = 59;

    // Vector functions
    NORM_P = 100;
    QUAD_OVER_LIN = 101;
    LOG_SUM_EXP = 102;
    MAX_ENTRIES = 103;
    SUM_LARGEST = 104;

    // Matrix functions
    LOG_DET = 200;
    NORM_PQ = 201;
    NORM_2_ELEMENTWISE = 202;
    MAX_ELEMENTWISE = 203;
    NORM_NUC = 204;
    LAMBDA_MAX = 205;
    MATRIX_FRAC = 206;

    // Atomic expressions
    LINEAR_MAP = 300;
    PROX_FUNCTION = 301;
  }
  Type expression_type = 1;
  Size size = 2;
  repeated Expression arg = 3;

  // DCP attributes
  Sign sign = 4;
  Curvature curvature = 5;

  ProximalOperator proximal_operator = 6;

  // CONSTANT, VARIABLE
  Constant constant = 7;
  Variable variable = 8;

  // INDEX
  repeated Slice key = 9;

  // NORM_P, NORM_P_Q and POWER
  double p = 10;
  double q = 11;

  // INDICATOR
  Cone cone = 12;

  // HUBER
  double M = 13;

  // SCALED_ZONE
  message ScaledZoneParams {
    double alpha = 1;
    double beta = 2;
    double c = 3;
    double m = 4;
  }
  ScaledZoneParams scaled_zone_params = 14;

  // HSTACK/VSTACK
  message StackParams {
    // Used when we split a *STACK() operator
    int32 offset = 1;
  }
  StackParams stack_params = 15;

  // SUM_LARGEST
  int32 k = 16;

  // LINEAR_MAP
  LinearMap linear_map = 17;
}

// Arbitrary convex problem of the form
// minimize    f(x)
// subject to  f_i(x) <=_K 0
message Problem {
  // Objective should be scalar-valued, f : R^n -> R
  Expression objective = 1;

  // Constraints can be vector-valued, f_i : R^n -> R^m, and should have
  // expression type INDICATOR
  repeated Expression constraint = 2;
}
